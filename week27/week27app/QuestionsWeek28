1. `[props](https://ru.reactjs.org/docs/components-and-props.html)` (намеренно сокращённо от англ. «properties» — свойства) и `[state](https://ru.reactjs.org/docs/state-and-lifecycle.html)` — это обычные JavaScript-объекты. Несмотря на то, что оба содержат информацию, которая влияет на то, что увидим после рендера, есть существенное различие: `props` передаётся *в* компонент (служат как параметры функции), в то время как `state` находится *внутри* компонента (по аналогии с переменными, которые объявлены внутри функции). `state` и `props` оба являются JS-объектами, но у них разное предназначение. Если `props` представляет входные данные, которые передаются в компонент извне, то состояние хранит такие объекты, которые создаются в компоненте и полностью зависят от компонента.
2. Состояние не должно меняться напрямую, не должно мутироваться, а функция push мутирует массив, то есть изменяет массив.
3. Нет, нельзя
4. **constructor()** — это единственное место, где `state` может изменяться напрямую. Во всех остальных местах `this.state` должен использоваться только для чтения
5. Так как функция setState асинхронная - она выходит из общей очереди и JS вначале выполнит console.log(this.state.checked) //#1 false , потом выполнит второй  console.log(this.state.checked) //#2  falseю. Чтобы вывести измененный state нужно использовать callback функции setState
6. У обычных и стрелочных функций по-разному определяется `this` . обработчики вызываются асинхронно, а методы в классах — это обычные функции с поздним связыванием. Поэтому мы не можем просто так повесить обработчик, так как он потеряет `this` . С таким определением придется постоянно писать подобный код:  
    
    ```jsx
    onClick={this.handleClick.bind(this)}
    /*** или так ***/
    onClick={() => this.handleClick()}
    ```
    

Вторая причина связана с производительностью. Оба предыдущих примера передачи обработчика порождают при каждом вызове функции `render` новые обработчики (так как функции сравниваются по ссылкам, а не по содержимому), а для React это критично. Поэтому правильный способ определения - стрелочная функция.

7.  Функциональные компоненты очень просты в создании.

Компонент принимает объект props, в котором содержаться значения переданные от родительского компонента. В props можно передавать любые типы, даже другие компоненты.

Функциональный компонент возвращает React-элемент. Он должен быть только один, если их больше, они должны быть обернуты родителем.

### **Классовые компоненты**

Главное отличие классового компонента от функционального это возможность хранить внутреннее состояния.

Классовый компонент должен содержать метод render(), который возвращает React-элемент. Доступ к props осуществляется через this.props. Обновление компонента происходит при изменении пропсов или состояния.

Чтобы получить возможность устанавливать state, нужно определить конструктор и вызвать метод super(), в конструктор и super передаются props. Само состояние изначально определяется в this.state, больше напрямую изменять state нельзя, это может привести к непредсказуемым последствиям.

State — очень важная часть, позволяющая хранить состояния приложения, и если в процессе работы приложения был вызван setState, который изменил state компонента, то компонент будет перерисован.

С приходом хуков, у функциональных компонентов появилась возможность хранить состояния, использовать методы жизненного цикла, и быть полноценными конкурентами классовых. При этом, их преимущества никуда не ушли. Начиная с 2019 года, популярность  функциональных компонентов выросла в разы, и на данный момент есть тренд написания приложений именно на них. 

Раньше, если вы писали функциональный компонент и осознавали, что вам нужно наделить его состоянием, вам приходилось превращать этот компонент в класс. Теперь же вы можете использовать хук внутри существующего функционального компонента.

Хук — это специальная функция, которая позволяет «подцепиться» к возможностям React. Например, хук `useState` предоставляет функциональным компонентам доступ к состоянию React.
8. В первую очередь, мы импортируем хук `useState` из React.
В функциональном компоненте нам недоступен `this`, поэтому мы не можем задать или считать состояние через `this.state`. Вместо этого мы вызываем хук `useState` напрямую изнутри нашего компонента. В `useState`  мы передаем исходное состояние. Вызов `useState` вернёт пару значений: текущее состояние и функцию, обновляющую состояние:
9.  Да
10. Используя UseState
11. Нет
12. С приходом хуков, у функциональных компонентов появилась возможность хранить состояния, использовать методы жизненного цикла, и быть полноценными конкурентами классовых. 
13. **Хуки** не работают внутри **классов**, напротив: они позволяют **использовать** React без **классов**.
14. 

```jsx
const name = this.props.name || 'Hello!';

```

Это сработает, но такой подход является не самым удачным из-за проблем с производительностью. В React предусмотрен способ устанавливать значения пропсов по умолчанию — `defaultProps`. 

```jsx
export default class Button extends React.Component {
    static defaultProps = {
        name: 'Hello!',
    };
    render() {
        const {name, ...props} = this.props;
        return (
            <button {...props}>
                {name}
            </button>
        );
    }
}
```
