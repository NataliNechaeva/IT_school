1. Главное отличие - локальное и сессионное хранилище доступны только на клиентской стороне, а cookie можно передавать на сервер. Сссионное хранилище хранит данные, пока продолжается текущая сессия. Если нам нужно надолго сохранить много пользовательских данных - используем  локальное хранилище.
2. `setItem()` — добавляет пару ключ-значение в локальное веб-хранилище

    `getItem()` — получает значение по ключу

3. Cookie способны собирать информацию о посещенных страницах и **времени**, проведенном на сайте, а также фиксировать отдельные действия, например, заполнение различных форм.

**Настройки профиля**. Cookie сохраняют языковые настройки, валюту покупки, геолокацию и так далее. Самый яркий пример — интернет-магазины, которые автоматически подставляют нужную **валюту** и **город доставки**

В большинстве случаев cookie позволяют получить практически полную **карту «путешествий**» пользователя по сайту

Рекламные. Предназначены для настройки таргетированных объявлений. Они помогают определить, с какого ресурса пользователь перешел на рекламное объявление. Могут быть сторонними.

4. С помощью вот такой длинной регулярки вы можете поддерживать сразу несколько платежных систем:

```jsx
/^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\d{3})\d{11})$/
```
5. 	<input type="number">

прописать pattern ="^[ 0-9]+$"

regExp = /^\d{1,}$/

6.
- regExp = /^([А-ЯA-Z]|[А-ЯA-Z][\x27а-яa-z]{1,}|[А-ЯA-Z][\x27а-яa-z]{1,}\-([А-ЯA-Z][\x27а-яa-z]{1,}|(оглы)|(кызы)))\040[А-ЯA-Z][\x27а-яa-z]{1,}(\040[А-ЯA-Z][\x27а-яa-z]{1,})?$/
- ([А-ЯЁ][а-яё]+[\-\s]?){3,}
7. HTML5 - этот метод валидации является наиболее поддерживаемым в современных браузерах. И он самый простой - нам достаточно определить тип `input` поля и расставить атрибуты `required`, которые отвечают за обязательность заполнения. 

В CSS существует четыре специальных псевдокласса, применимых к полям формы: `:valid` (*валидное поле*), `:invalid` (*невалидное*), `:required` (*обязательное*) и `:optional` (*необязательное*). Их можно использовать, чтобы добавлять некоторые — хотя и весьма ограниченные — подсказки пользователям, заполняющим форму.

Используя `:valid` и `:invalid`, мы можем показать пользователю, правильно ли заполнено поле по мере ввода.

Стилизация состояний :required и :optional сама по себе не особо полезна, поскольку эта информация обычно указывается в подписях к полям формы. Однако мы можем объединить эти состояния с псевдоклассами :valid / :invalid и стилизовать их комбинации. Например, мы хотим показывать лишь положительный результат, когда валидно обязательное к заполнению поле.

Однако, нам на помощь приходит атрибут `pattern`. Этот атрибут принимает в себя значение регулярного выражения. В нашем случае рассмотрим вариант паттерна для ввода мобильного телефона в международном формате.

JavaScript даёт намного больше возможностей для улучшения работы пользователей с формами. Устанавливая атрибуты min, max и step, мы можем быть уверены в правильности значения только тогда, когда пользователь использует специальные контролы числового поля. В результате всё, что получит пользователь — это сообщение об ошибке для первого поля. Кроме того, в этом сообщении будет указано лишь одно несоответствие из двух требуемых. Такое поведение можно исправить, изменяя показываемые валидатором сообщения. Валидируя поля, браузер проверяет их по определённому списку потенциальных ошибок. В каждом поле содержится специальный объект `validity`, включающий в себя список булевых значений, характеризующих ту или иную проверку на валидность. По умолчанию браузер отобразит лишь одну ошибку. Что мы можем сделать, так это проверить все эти значения самостоятельно и, если найдутся ошибки, сохранить их. Как только мы сохраним все ошибки для одного поля, мы можем отобразить весь их список в виде специального сообщения об ошибке при помощи функции setCustomValidity().

8. Однако с использованием псевдоклассов связана одна проблема: стили применяются до того, как пользователь начнёт работу с формой. Поля, обязательные для заполнения, сразу подсветятся нам как `:invalid`, а необязательные — как `:valid`. Это значит, что пользователь, даже не приступив к заполнению формы, может сразу же получить негативную обратную связь. Совсем некрасиво и непонятно для пользователя, что от него хотят.

 Используя специальный объект `validity`  по умолчанию браузер отобразит лишь одну ошибку.
